open Globals
open Utilities

type direction = Left | Right | Straight

(* Retourne une vitesse nulle *)
fun no_movement() returns (rspeed: wheels)
let
  rspeed = { left = 0.0; right = 0.0 }
tel

fun speed_arriving(b: bool) returns (rspeed: wheels; arriving: bool)
let
  rspeed = no_movement();
  arriving = b;
tel;

(* Calcule la vitesse maximale des roues en fonction de la limitation de vitesse *)
fun max_rspeed(speed_limit : float) returns (max : float)
var w : float;
let
  w = (speed_limit *. 360.0) /. (pi *. cD);
  max = min_float(cMAXWHEEL, w);
tel

(* Retourne la direction à prendre en fonction de la couleur détecter par le capteur RC *)
fun get_direction(col : color) returns (dir : direction)
let
  dir = if compare_colors(col, cyan) >. 0.71 then Right
        else if compare_colors(col, magenta) >. 0.71 then Left
        else Straight;
tel

fun calculate_rota_turn(col : color; max_rota : float) returns (rota_turn : float; dir : direction)
var diff_guide : float;
let
  dir = get_direction(col);
  diff_guide = 1.0 -. compare_colors(col, blue);
  rota_turn = max_rota *. (1.0 -. diff_guide);
tel

(* Retourne la vitesse de rotation des roues en fonction de la couleur détecter par le capteur RC *)
node calculate_rspeed(sens : sensors; speed_limit : float) returns (rspeed : wheels)
var max_rota, rota_turn: float; dir: direction; colRC : color;
let
  colRC = sens.s_road;
  max_rota = max_rspeed(speed_limit);
  (rota_turn, dir) = calculate_rota_turn(colRC, max_rota);
  rspeed = if dir = Right then { left = max_rota ; right = rota_turn}
           else if dir = Left then { left = rota_turn ; right = max_rota }
           else { left = max_rota ; right = max_rota };
tel

(* Retourne true si l'action est Go *)
fun is_go(act : action) returns (b : bool)
let
  b = act = Go
tel

(* Retourne true si l'action est Turn *)
fun is_turn(act : action) returns (b : bool)
let
  b = act = Turn
tel

(* Retourne true si l'action est Stop *)
fun is_stop(act : action) returns (b : bool)
let
  b = act = Stop
tel

(* Fonction utilisé lorsque l'action est Go, détermine la vitesse des roues et si on doit changer d'étape *)
node go_state(sens : sensors; step_iti : itielt; old_step : int) returns (rspeed : wheels; arriving : bool; step : int)
let
  rspeed = calculate_rspeed(sens, step_iti.param);
  step = if compare_colors(sens.s_road, green) = 1.0 
         then old_step + 1 else old_step;
  arriving = false;
tel

node controller(sens : sensors; iti : itielts)
       returns (rspeed : wheels; arriving : bool)
var last step: int = 0; step_iti : itielt;
let
  step_iti = iti[> last step <];

  automaton
    state Idle do
      (rspeed, arriving) = speed_arriving(false);
      unless is_go(step_iti.act) then Go
           | is_turn(step_iti.act) then Turn
           | is_stop(step_iti.act) then Stop
    state Go do
      (rspeed, arriving, step) = go_state(sens, step_iti, last step);
      unless is_turn(step_iti.act) then Turn
           | is_stop(step_iti.act) then Stop
           | compare_colors(sens.s_road, red) = 1.0 and compare_colors(sens.s_front, red) = 1.0 then TrafficLight
           (* | sens.s_sonar > 0 then Obstacle *)
    state Turn do
      (rspeed, arriving) = speed_arriving(false);
      (*on fait tourner le véhicule sur lui même tant que le l'angle n'est pas égale au param *)
    state Obstacle do
      (rspeed, arriving) = speed_arriving(false);
      unless sens.s_sonar = 0 then Idle
    state TrafficLight do
      (rspeed, arriving) = speed_arriving(false);
      unless compare_colors(sens.s_front, green) = 1.0 then Idle
    state Stop do
      (rspeed, arriving) = speed_arriving(true);
  end
tel
