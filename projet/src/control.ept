open Globals
open Utilities

type simulation = Running | Stopped
type runningAction = (* Idle | *) G | T | S

fun no_movement() returns (rspeed: wheels)
let
  rspeed = { left = 0.0; right = 0.0 }
tel

fun max_rspeed(speed_limit : float) returns (max : float)
var w : float;
let
  w = (speed_limit *. 360.0) /. (pi *. cD);
  max = min_float(cMAXWHEEL, w);
tel

fun get_movement_from_color_and_param(col : color; speed_limit : float) returns (rspeed : wheels)
var max_rota, rota_turn: float;
let
  max_rota = max_rspeed(speed_limit);
  rota_turn = max_rota *. (1.0-.0.2);
  rspeed = if compare_colors(col, cyan) >. 0.85 then { left = max_rota ; right = rota_turn}
           else if compare_colors(col, magenta) >. 0.85 then { left = rota_turn ; right = max_rota }
           else { left = max_rota ; right = max_rota };
tel

node controller(sens : sensors; iti : itielts)
       returns (rspeed : wheels; arriving : bool)
var last step: int = 0; step_iti : itielt;
let
  step_iti = iti[> last step <];

  automaton
    state Idle do
      rspeed = no_movement();
      arriving = false;
      unless step_iti.act = Go then G 
           | step_iti.act = Turn then T
    state G do
      (*
      Tant que le vehicule se trouve sur le guide bleu on avance tout droit
      Sinon:
        - si RC capte couleur cyan alors on pivote le véhicule vers la droite
        - si RC capte couleur magenta alors on pivote le véhicule vers la gauche 
      *)
      rspeed = get_movement_from_color_and_param(sens.s_road, step_iti.param);
      step = if compare_colors(sens.s_road, green) = 1.0 then last step + 1 else last step;
      arriving = false;
      unless step_iti.act = Turn then T
           | step_iti.act = Stop then S
    state T do
      rspeed = no_movement();
      arriving = false;
      (*on fait tourner le véhicule sur lui même tant que le l'angle n'est pas égale au param *)
    state S do
      rspeed = no_movement();
      arriving = true;
  end
tel
